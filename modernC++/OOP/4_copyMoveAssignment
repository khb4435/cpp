#include <iostream>
#include <string>
//소멸자 ,move assignment constructor는 예외가 발생되면 안됨!
class Cat{
    public:
        void print(){
            std::cout<<mName<<" "<<mAge<<std::endl;
        }
        //1.생성자
        Cat() = default; 
        Cat(std::string name,int age):mName{std::move(name)},mAge{age}{
            std::cout<<"생성자"<<std::endl;
        }
        //2.소멸자
        ~Cat() noexcept{ //소멸자하는데 인자가 필요허냐?
            //delete mPtr;
            std::cout<<"소멸자"<<std::endl;
        }
        //3.copy assignment : =로 복사처리함, 근데 a=b=c 계속 할 수 있으므로
        //리턴값 주의하기
        //assignment는 새로운 객체에 하는게 아님!!!
        //l value받음
        Cat& operator=(const Cat& other){
            if(&other == this){
                return *this;
            }                    
            mName = other.mName;
            mAge = other.mAge;
            std::cout<<"copy assignment"<<std::endl;
            return *this;
        }
        //4.move assignment : =로 이동 처리함 근데 = = 계속할 수 있으므로
        //마찬가지로 리턴값 주의
        ////assignment는 새로운 객체에 하는게 아님!!!
        //r value 받음
        Cat& operator=(const Cat&& other) noexcept {
            if(&other == this){
                return *this;
            }    
            mName = std::move(other.mName);
            mAge = other.mAge;
            std::cout<<"move assignment"<<std::endl;
            return *this;
        }
        //delete키워드로 막을 수도 있음
        //Cat(const Cat&other) = delete;
    private:
        std::string mName;
        int mAge;
        //char *mPtr;
}

int main(){
    Cat kitty{"kitty",1};
    Cat nabi{"nabi",2};
    kitty = nabi; //copy assignment

    Cat muni{"muni",1};
    Cat hoya{"hoya",2};
    muni = std::move(hoya); //move assignment

    //새로운 객체네? constructor겠구나 lvalue네? copy네
    //기존객체고 =네? assignment네 rvalue네? move네 

    return 0;
}
