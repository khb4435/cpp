//std::move : L value를 R value로 바꿈으로서
//리소스 오너십을 넘겨준다
//일반적으로 복사생략을 통해서 더 빠른 코드를 만드는데 목적이 있습니다.
#include <iostream>
int main(){
    std::string a = "nocope";
    std::cout<<a<<std::endl; // nocope

    std::string b = std::move(a);
    std::cout<<b<<std::endl; // nocope
    std::cout<<a<<std::endl; // 출력없음
}


////2
void storeByLRef((const) std::string &s){
    std::string b=std::move(s);
    std::cout<<b<<std::endl; //abc
    //const , std::move -> copy
}
void storeByRRef(std::string &&s){
    std::string b=std::move(s);
}

int main(){
    std::string a = "abc"; 
    storeByLRef(a);
    std::cout<<a<<std::endl; //abc
}


////3
class Cat{
    public:
        void setName(const std::string &name){
            mName = std::move(name);
        }
    private:
        std::string mName;
}

int main(){
    Cat kitty;
    std::string s = "nocope";

    kitty.setName(s); //0 copy에서 const , std::move를 통해 
    //정말 필요한 1 copy를 만들어줌 (s에도 값이 있음)
}


//우리의 목적 lvalue넘길때 1copy, rvalue 넘길때 0 copy
//함수 아규먼트를 벨류로 받아라
class Cat{
    public:
        void setName(std::string name){
            mName = std::move(name);
        }
    private:
        std::string mName;
}

int main(){
    Cat kitty;
    std::string s = "nocope";

    kitty.setName(s); //1 copy
    kitty.setName("nocope"); //0copy
    //name = "nocope"에서 복사생략 일어남
}
