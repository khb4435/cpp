//중요한거 오너십!!
//l value reference(&) vs R value reference(&&)
//l value를 r value로 만들어주는 std::move

//재사용가능한것 l value
//재사용불가능한것 r value

#include <iostream>
int main(){
    int a=0;
    int b = std::move(a); //a가 r value가 되었고 
    //다시 불려지지 않을 놈이 되었음.
}


//////////////////////////////////////////////////////////////////////////////////////////
void storeByValue(std::string s){
    std::string b=s;
}
void storeByLRef(std::string &s){
    std::string b=s;
}
void storeByRRef(std::string &&s){
    std::string b=std::move(s);
    //rvalue로 받았는데 s는 함수내에서 또 lvalue로 쓰일 수 있으므로
}

int main(){
    std::string a = "abc"; 
    storeByValue(a);
    storeByLRef(a);
    //storeByRRef(a); //wrong! -> Rvalue를 받는데 l value를 넘겨줘서 그렇다
    storeByRRef(std::move(a));
    storeByRRef("abc");
    // r value로 넘겨주는 순간 caller파트에서는 소유권을 포기하기때문에 function 안에서는 copy를 할 필요가 없어집니다. 
}
